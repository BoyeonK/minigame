syntax = "proto3";

package S2C_Protocol;
option csharp_namespace = "Google.Protobuf.Protocol";

import "S2C_Protocol_Common.proto";

//C_RequestGameState에 대한 응답
//Player의 ID를 전달.
message S_P_State {
    repeated UnityGameObject objects = 1;
    repeated string playerIds = 2;
    int32 playerId = 3;
}

//게임 종료시 게임 결과 전달 및, 클라이언트로 하여금 결과창으로 이동 유도.
//현재 이 로직에는 문제?가 있는데 일단 DB에 결과를 업데이트 하는 과정에서 기록과 elo를 업데이트하는 과정에 트랜잭션이 적용되어 있지 않음.
//가령, elo는 변화하되 record는 변화하지 않을 수 있음.
//그리고, 해당 결과를 DB에 반영하기 이전 단계에서 클라이언트에게 결과를 전송함. (이건 굳이 문제라고 보기는 그렇지만)
message S_P_Result {
    bool isWinner = 1;
    repeated int32 scores = 2;
}

message S_P_ReadyForStart {

}

//repeated를 사용했으면 어땠을까?
message S_P_RequestPlayerBarPosition {
    float ex = 1;
    float ez = 2;
    float wx = 3;
    float wz = 4;
    float sx = 5;
    float sz = 6;
    float nx = 7;
    float nz = 8;
}

message C_P_ResponsePlayerBarPosition {
    XYZ position = 1;
}

message S_P_ChangePlayerBarPosition {
    repeated XYZ positions = 1;
}

message S_P_Bullet {
    UnityGameObject bullet = 1;
    XYZ moveDir = 2;
    float speed = 3;
    int32 lastCollider = 4;
}

message S_P_Bullets {
    repeated S_P_Bullet bullets = 1;
}

message C_P_CollisionBar {
    UnityGameObject bullet = 1;
    XYZ moveDir = 2;
    float speed = 3;
}

message C_P_CollisionGoalLine {
    int32 point = 1;
}

message S_P_RenewScores {
    repeated int32 scores = 1;
}

//개짓하면 곤란하므로, 이 패킷은 암호화를 적용하겠음.
message S_P_KeepAlive {
    uint64 tick = 1;
}

message C_P_ResponseKeepAlive {
    uint64 tick = 1;
}