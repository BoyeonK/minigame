syntax = "proto3";

package S2C_Protocol;
option csharp_namespace = "Google.Protobuf.Protocol";

import "S2C_Protocol_Ingame.proto";
import "S2C_Protocol_Common.proto";

//최초에 TCP방식의 Connect가 성공하면 해당 session의 보안레벨은 '보안레벨 0'이다.
//MsgId 0~4영역(HandShake과정) 보안레벨 0에서 통신 가능.
//1. (S_Welcome) 
    //서버의 RSA key pool에서 공개키를 하나 꺼내서 gameversion과 함께 클라이언트에 전송.
//2. (C_Welcome)
    //받은 gameversion이 맞지 않으면, 메세지를 출력하고 클라이언트 종료.
    //아닌 경우, AES key를 하나 만들고 세션에 저장.
    //해당 AES key를 서버로부터 받은 RSA public key로 암호화하여 서버에 전송.
    //해당 AES key로의 암호화 및 복호화가 양쪽에서 올바르게 진행되는지 확인할 목적으로 임의의 문자열도 같이 전송.
//3. (S_WelcomeResponse -> S_Encrypted)
    //클라이언트로부터 받은 문자열을 받아 S_WelcomeResponse으로 직렬화한다.
    //'protobuf로 직렬화된 바이너리'를 암호화한다. '전송할 내용'을 암호화해서 해당 바이너리 영역을 protobuf로 직렬화할까도 고려해보았으나, 2가지 이유로 지금 순서를 사용하게 되었다.
        //1. Handler함수를 재사용 할 수 있다.
        //2. 직렬화된 바이너리를 암호화하는 경우, 암호화 할지 말지 여부가 자유롭다.
            //전송할 내용을 암호화해서 직렬화하기로 프로토콜이 정해지면, 해당 내용은 반드시 암호화해서 전송해야한다.
    //AES-GCM방식을 사용하고, 복호화된 바이너리를 어떤 패킷으로서 캐스팅해야 할지(서버 C++, 클라 C#) 단서를 주기 위해 msgId를 같이 전송한다.
        //같이 전송된 msgId는, tag와 함께 해당 암호화의 무결성을 검증할 추가 인증수단으로서도 활용된다.
//4. 클라이언트에서 S_Encrypted를 받아 핸들러 함수를 실행한다.
    //정상적으로 동작한 경우 iv, cyphertext, tag, msgId를 통해 S_WelcomeResponse패킷이 복호화되고 해당 패킷에 대한 핸들러 함수가 실행된다.
    //S_WelcomeResponse의 핸들러 함수의 동작으로서 HandShake과정이 끝난다.
//이후 보안레벨 1로 설정한다.
//보안레벨 1의 경우 통신가능한 MsgId영역은 0~8이다.(로그인, 계정생성까지 가능) FM대로 가자면 3~8로 하는 것이 명확하고 좋기는 하다.

//클라이언트가 전송한, AES방식의 암호화된 패킷(C_Encrypted)에 대한 접근은 보안 레벨은 0에서도 동작하도록 설계되어있다.
    //이 사실을 안 누군가가, 로그인하지 않고 msgId 4인 패킷을 무차별 난사한다면, 의미없는 패킷을 복호화하는데 서버의 자원이 소진 될 수 있다.
    //복호화 불가능한 가짜 패킷이나 허용되지 않은 msgId영역에서의 전송이 반복될 경우, 해당 IP혹은 Session을 차단하는 것을 고려해 보았으나..
    //누가 내 토이 프로젝트에 설마 그렇게 까지 하겠는가..
message S_Welcome {
    bytes publicKey = 1;
    int32 gameversion = 2;
}

message C_Welcome {
    bytes aesKey = 1;
    string message = 2;
}

message S_WelcomeResponse {
    string message = 1;
    bool success = 2;
}

message S_Encrypted {
    bytes iv = 1;
    bytes ciphertext = 2;
    bytes tag = 3;
    int32 msgId = 4;
}

message C_Encrypted {
    bytes iv = 1;
    bytes ciphertext = 2;
    bytes tag = 3;
    int32 msgId = 4;
} 

//여기서부터 보안레벨 1 영역

//클라이언트의 로그인 요청. 민감한 정보이므로 이 패킷은 암호화되서 전송됨.
message C_Login {
    string id = 1;
    string password = 2;
}

//1. 로그인 성공 => 0이 아닌 dbid
//2. 로그인 실패. 비밀번호 틀림 => dbid = 0
//3. 로그인 실패. 없는 아이디 => err 문자열 전송. (UTF-16으로 인코딩)
    //유효한 dbid가 전송된 순간부터는 `보안레벨 2`이다.
    //이제부터는 LobbyScene에서 전송 가능한 모든 MsgId의 수신에 대해 서버에서 처리한다.
        //현재 로그인한 세션에서의, 재 로그인 요청을 처리할 수 있으며...(정상적인 상황 아님) 그렇게 될 경우 dbid를 덮어쓴다.
        //따라서 FM대로 하자면, 모든 수신이 아니라 msgId 3~4, 그리고 9~ 에 대한 수신에 대한 처리를 해야 한다.

//서버에서의 응답. 암호화되서 전송됨.
message S_Login {
    oneof value_case {
        int32 dbid = 1;
        string err = 2;
    }
}

//계정 생성 요청. 암호화되서 전송됨.
message C_CreateAccount {
    string id = 1;
    string password = 2;
}

//계정 생성 성공여부. 암호화 할 필요없음.
message S_CreateAccount {
    bool success = 1;
    string err = 2;
}

//여기서부터 보안레벨 2 영역

//연결을 종료하고 Session을 소거하는 것이 아닌, 해당 Session을 유지하면서
//다른 dbid로의 연결을 가능하게 할 목적.
//Session에서 dbid에 관한 정보를 지우고 다시 보안레벨 1로 낮춘다.
message C_Logout {
    int32 dbid = 1;
}

message S_Logout {
    bool success = 1;
}

//매치메이킹 영역
//1. (로그인이 완료된) 클라이언트에서 원하는 게임id를 담아 매치메이킹을 요청한다
//2. 서버에서 매치메이킹 가능 여부를 판단 후 결과를 클라이언트에 전송
    //2-1. 모종의 이유로 대기열 접속이 불가능 할 수 있음. (현재 진행중인 게임이 있을 경우(탈주자), 점검중인 경우 등을 고려)
    //2-2. 성공한 경우, 클라이언트 및 서버에서 _matchState를 변경
//3. 클라이언트의 요청에 의한 매치메이킹 종료
    //3-1. 모종의 이유로 실패할 수 있음 (요청이 보내지는 과정에서 이미 매칭이 완료된 경우, 완료된 매칭을 우선으로 함.)
    //3-2. 성공한 경우, 클라이언트 및 서버에서 _matchState변경
//4. elo기준으로 적당한 인원조합을 꾸려 매칭을 완료. 이 플레이어들을 모아 게임 룸을 만든다.
//대기열을 elo순으로 정렬. 게임인원만큼의 모집단에서 분산이 허용elo 분산보다 낮은 조합을 찾고, 그 중에서 다시 분산이 가장 낮은 조합부터 매칭 시도.
    //4-1. 해당 session이 살아있는지 확인하기 위해 매칭된 그룹에게 S_KeepAlive 패킷을 전송
        //4-1-1. 모든 인원으로부터 C_KeepAlive패킷을 받은 경우 매칭완료 S_MatchCompleted
        //4-1-2. 내가 아닌 '특정 인원'이 유효하지않아 매치메이킹이 재개됨 S_RedoMatchMake
        //4-1-3. 그 '특정 인원'이 나임. S_ExcludedFromMatch 매치메이킹에서 제외됨.
            //Session의 핑이 1000ms이상이거나 (S_KeepAlive에 대한 응답 C_KeepAlive가 1초 이상 걸림), 
            //C_MatchMakeCancel에 대한 패킷핸들러 함수가 동작했거나, (플레이어의 매칭 취소 요청)

//클라이언트의 매칭 요청
message C_MatchmakeRequest {
    int32 gameId = 1;
}

//매칭 요청에 대한 처리 결과를 담은 응답
message S_MatchmakeRequest {
    bool isSucceed = 1;
    int32 gameId = 2;
    string err = 3;
}

//클라이언트의 매칭 취소 요청
message C_MatchmakeCancel {
    int32 gameId = 1;
}

//매칭취소 요청에 대한 처리 결과를 담은 응답
message S_MatchmakeCancel {
    bool isSucceed = 1;
    int32 gameId = 2;
    string err = 3;
}

//올바른 조합을 찾았을 때, Session의 유효성 검사용
message S_MatchmakeKeepAlive {
    int32 gameId = 1;
    int64 sentTimeTick = 2;
}

//유효성 검사에 대한 응답.
message C_MatchmakeKeepAlive {
    int32 gameId = 1;
    int64 sentTimeTick = 2;
}

//매칭 실패로 인한 매칭 재개 통보.
message S_RedoMatchmake {
    int32 gameId = 1;
}

//매칭 취소요청, 혹은 안좋은 연결상태로 인해 서버의 매칭 대기열에서 벗어남을 통보.
message S_ExcludedFromMatch {
    bool isUserRequest = 1;
}

//매칭성공. 해당 게임을 준비하기위해 Scene변경을 유도.
message S_MatchmakeCompleted {
    int32 gameId = 1;
}

//Scene을 변경하고, 게임 리소스의 로딩이 얼마나 진행됬는가를 서버에 전송
//모든 인원으로부터 persentage 100의 응답을 받거나, 허용된 일정 시간이 초과한 경우 본격적으로 게임 시작.
message C_GameSceneLoadingProgress {
    int32 persentage = 1;
}

message S_GameStarted {
    int32 gameId = 1;
}

//세션의 종료 및 초기 화면으로 돌아가는것을 유도.
message S_KillSession {
    string err = 1;
}

//클라이언트의 종료를 유도
message S_KillApplication {
    string err = 1;
}